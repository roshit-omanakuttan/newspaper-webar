<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebAR â€¢ Video + Model (smoothed + instant autoplay)</title>
  <style>
    html,body{margin:0;height:100%;background:#0b0b10;color:#eaeaf5}
    #ar{position:fixed;inset:0; touch-action:none;}
    #status{position:fixed;top:10px;left:10px;background:#121222;border:1px solid #2a2a44;border-radius:10px;padding:8px 10px;z-index:10}
    #unmute{position:fixed;right:10px;top:10px;padding:8px 10px;border:0;border-radius:10px;background:#22c55e;color:#0b0b10;font-weight:700;display:none;z-index:11}
    /* keep the HTMLVideoElement in the DOM to satisfy mobile autoplay heuristics */
    #hiddenVideo{position:fixed;left:-9999px;top:-9999px;width:1px;height:1px}
  </style>
  <link rel="icon" href="data:,"/>
  <script src="./mindar-image-three.prod.js"></script>
</head>
<body>
<div id="ar"></div>
<div id="status">Idle</div>
<button id="unmute">ðŸ”Š sound on</button>
<!-- same element is used as the VideoTexture source -->
<video id="hiddenVideo" playsinline muted autoplay loop preload="auto"></video>

<script>
  const status = (t)=>{ document.getElementById('status').textContent = t; };
  const loadScript = (src) => new Promise((resolve, reject) => {
    const s = document.createElement('script'); s.src = src;
    s.onload = resolve; s.onerror = () => reject(new Error('Failed to load '+src));
    document.head.appendChild(s);
  });
  const tryPlay = (v) => { const p = v.play?.(); if (p && p.catch) p.catch(()=>{}); };

  async function init(){
    if (!window.MINDAR || !window.MINDAR.IMAGE) { status('MindAR failed to load'); return; }
    const THREE_AR = window.MINDAR.IMAGE.THREE;

    // --- NEW: Animation state ---
    let mixer = null;                   // NEW
    const actions = [];                 // NEW
    const clock = new THREE_AR.Clock(); // NEW

    // Prime the video EARLY (muted) so autoplay works
    const video = document.getElementById('hiddenVideo');
    video.src = './sunglass.mp4';
    video.muted = true;
    video.playsInline = true;
    video.autoplay = true;
    video.loop = true;
    video.preload = 'auto';
    tryPlay(video);
    document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) tryPlay(video); });

    // MindAR with smoothing/tolerances
    const mindarThree = new window.MINDAR.IMAGE.MindARThree({
      container: document.querySelector('#ar'),
      imageTargetSrc: './sunglass.mind',
      filterMinCF: 0.0008,
      filterBeta:  0.01,
      warmupTolerance: 8,
      missTolerance:   8,
    });
    const { renderer, scene, camera } = mindarThree;
    scene.add(new THREE_AR.HemisphereLight(0xffffff, 0x222233, 1.0));

    const anchor = mindarThree.addAnchor(0);

    // -------- Smoothed rig --------
    const smoothed = new THREE_AR.Group();
    smoothed.visible = false;
    scene.add(smoothed);

    const _tPos  = new THREE_AR.Vector3();
    const _tQuat = new THREE_AR.Quaternion();
    const _tScl  = new THREE_AR.Vector3();
    const SMOOTH = 0.18;

    // Video plane
    const videoTex = new THREE_AR.VideoTexture(video);
    const planeMat = new THREE_AR.MeshBasicMaterial({
      map: videoTex,
      side: THREE_AR.DoubleSide,
      depthWrite: false,
    });
    planeMat.polygonOffset = true;
    planeMat.polygonOffsetFactor = 1;
    planeMat.polygonOffsetUnits  = 1;

    const plane = new THREE_AR.Mesh(
      new THREE_AR.PlaneGeometry(1.0, 1.414),
      planeMat
    );
    plane.position.set(0, 0, -0.03);
    plane.renderOrder = 0;
    plane.visible = false;
    smoothed.add(plane);

    const unmuteBtn = document.getElementById('unmute');
    unmuteBtn.addEventListener('click', ()=>{
      video.muted = false;
      tryPlay(video);
      unmuteBtn.style.display = 'none';
    });

    // On detection: show + resume animations
    anchor.onTargetFound = () => {
      status('Marker detected âœ…');
      smoothed.visible = true;
      plane.visible = true;
      try { video.pause(); video.currentTime = 0; } catch(_) {}
      tryPlay(video);
      unmuteBtn.style.display = 'inline-block';

      // NEW: resume animation
      actions.forEach(a => a.paused = false);
    };

    // On lost: hide + pause animations
    anchor.onTargetLost  = () => {
      status('Searching for markerâ€¦');
      smoothed.visible = false;
      plane.visible = false;
      video.pause();
      unmuteBtn.style.display = 'none';

      // NEW: pause animation
      actions.forEach(a => a.paused = true);
    };

    // Start AR and smooth-follow the live anchor
    await mindarThree.start();
    status('Searching for markerâ€¦');
    renderer.setAnimationLoop(()=>{
      // NEW: tick animation mixer
      const dt = clock.getDelta();
      if (mixer) mixer.update(dt);

      // decompose current live anchor pose
      anchor.group.matrixWorld.decompose(_tPos, _tQuat, _tScl);
      // ease smoothed rig toward it
      smoothed.position.lerp(_tPos, SMOOTH);
      smoothed.quaternion.slerp(_tQuat, SMOOTH);
      smoothed.scale.lerp(_tScl, SMOOTH);
      renderer.render(scene, camera);
    });
    tryPlay(video);

    // --- Load GLTF loader & model ---
    window.THREE = THREE_AR;
    await loadScript('https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js');
    try {
      await loadScript('https://unpkg.com/three@0.128.0/examples/js/libs/draco/draco_decoder.js');
      await loadScript('https://unpkg.com/three@0.128.0/examples/js/loaders/DRACOLoader.js');
    } catch(_) {}

    const loader = new THREE.GLTFLoader();
    if (THREE.DRACOLoader) {
      const draco = new THREE.DRACOLoader();
      draco.setDecoderPath('https://unpkg.com/three@0.128.0/examples/js/libs/draco/');
      loader.setDRACOLoader(draco);
    }

    loader.load('./watch.glb', (gltf) => {
      const model = gltf.scene || (gltf.scenes && gltf.scenes[0]);
      if(!model){ console.error('GLB has no scene'); return; }

      model.scale.set(0.25, 0.25, 0.25);
      model.position.set(0, 0.1, 0.05);
      model.rotation.set(Math.PI / 2, 0, 0);
      model.renderOrder = 2;
      model.traverse(o => { if (o.isMesh && o.material) o.material.depthTest = true; });

      smoothed.add(model);

      // --- NEW: build & play animations if present ---
      if (gltf.animations && gltf.animations.length) {
        mixer = new THREE_AR.AnimationMixer(model);
        gltf.animations.forEach((clip, i) => {
          const action = mixer.clipAction(clip);
          action.loop = THREE_AR.LoopRepeat;      // or LoopOnce
          action.clampWhenFinished = true;
          action.enabled = true;
          actions.push(action);
        });
        // auto-play the first clip
        actions[0].reset().play();
      }

      // Drag-to-spin with inertia (unchanged)
      const el = document.getElementById('ar');
      let dragging=false,lastX=0,velZ=0;
      const friction=0.96, dragFactor=0.008;

      el.addEventListener('pointerdown', e => {
        dragging=true; lastX=e.clientX; velZ=0; el.setPointerCapture(e.pointerId);
      });
      el.addEventListener('pointermove',  e => {
        if(!dragging) return;
        const dx=e.clientX-lastX; lastX=e.clientX;
        model.rotation.z -= dx*dragFactor;
        velZ = -dx*dragFactor;
      });
      const endDrag = e => { dragging=false; try{ el.releasePointerCapture(e.pointerId); }catch{} };
      el.addEventListener('pointerup', endDrag);
      el.addEventListener('pointercancel', endDrag);
      el.addEventListener('pointerleave', endDrag);

      (function spin(){
        if(!dragging){
          model.rotation.z += velZ;
          velZ *= friction;
          if(Math.abs(velZ)<1e-4) velZ=0;
        }
        requestAnimationFrame(spin);
      })();
    }, undefined, (err) => {
      console.error('GLB load error:', err);
      status('Failed to load sunglass.glb');
    });
  }

  window.addEventListener('load', init);
</script>
</body>
</html>
